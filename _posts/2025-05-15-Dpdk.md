---
layout: post
title: Dpdk代码
subtitle: 
cover-img: 
thumbnail-img: /assets/img/dpdk.jpeg
share-img: 
tags: [install]
author: Jamie
---

{: .box-success}
Dpdk学习过程中记录下来的代码

### Udp

- upd收发包，arp-resp

```c
#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <rte_eal.h>
#include <rte_ethdev.h>
#include <rte_mbuf.h>
#include <rte_ip.h>
#include <rte_udp.h>
#include <rte_memcpy.h>
#include <rte_log.h>

#define RX_RING_SIZE 1024
#define TX_RING_SIZE 1024
#define NUM_MBUFS 8191
#define MBUF_CACHE_SIZE 250
#define BURST_SIZE 32

#define ENABLE_SEND 1
#define ENABLE_ARP 1

#if ENABLE_ARP

#define MAKE_IPV4_ADDR(a, b, c, d) (a + (b<<8) + (c<<16) + (d<<24))
static uint32_t gLocalIp = MAKE_IPV4_ADDR(192, 168, 42, 128);

#endif

#if ENABLE_SEND

static uint32_t gSrcIp;
static uint32_t gDstIp;

static uint8_t gSrcMac[RTE_ETHER_ADDR_LEN];
static uint8_t gDstMac[RTE_ETHER_ADDR_LEN];

static uint16_t gSrcPort;
static uint16_t gDstPort;

#endif

// 网卡配置
static struct rte_eth_conf port_conf = {
    .rxmode = {
        .max_rx_pkt_len = RTE_ETHER_MAX_LEN,
    },
};

// 初始化网卡
static int init_port(uint16_t port_id, struct rte_mempool *mbuf_pool) {

	struct rte_eth_dev_info dev_info;
	rte_eth_dev_info_get(port_id, &dev_info); //

    int ret;
    uint16_t nb_rxd = RX_RING_SIZE;
    uint16_t nb_txd = TX_RING_SIZE;

    // 配置网卡
    ret = rte_eth_dev_configure(port_id, 1, 1, &port_conf);
    if (ret < 0) {
        rte_exit(EXIT_FAILURE, "Failed to configure port %u\n", port_id);
    }

    // 设置接收队列
    ret = rte_eth_rx_queue_setup(port_id, 0, nb_rxd, rte_eth_dev_socket_id(port_id), NULL, mbuf_pool);
    if (ret < 0) {
        rte_exit(EXIT_FAILURE, "Failed to setup RX queue for port %u\n", port_id);
    }

#if ENABLE_SEND
    // 设置发送队列
    struct rte_eth_txconf txq_conf = dev_info.default_txconf;
    txq_conf.offloads = port_conf.txmode.offloads;
    ret = rte_eth_tx_queue_setup(port_id, 0, nb_rxd, rte_eth_dev_socket_id(port_id), &txq_conf);
    if (ret < 0) {
        rte_exit(EXIT_FAILURE, "Failed to setup TX queue for port %u\n", port_id);
    }
#endif

    // 启动网卡
    ret = rte_eth_dev_start(port_id);
    if (ret < 0) {
        rte_exit(EXIT_FAILURE, "Failed to start port %u\n", port_id);
    }

    // 启用混杂模式（接收所有流量）
    rte_eth_promiscuous_enable(port_id);
    printf("Port %u initialized, promiscuous mode ON\n", port_id);

    return 0;
}

static int encode_arp(uint8_t *msg, uint8_t *dst_mac, uint32_t sip, uint32_t tip)
{
    // 1 ethhdr
    /*
    | Destination MAC | Source MAC      | Type  |
    |-----------------|-----------------|-------|
    | 00 1A 2B 3C 4D 5E | 00 0A 0B 0C 0D 0E | 08 00 |
    */
    struct rte_ether_hdr * eth = (struct rte_ether_hdr * )msg;
    rte_memcpy(eth->s_addr.addr_bytes, gSrcMac, RTE_ETHER_ADDR_LEN);
    rte_memcpy(eth->d_addr.addr_bytes, dst_mac, RTE_ETHER_ADDR_LEN);
    eth->ether_type = htons(RTE_ETHER_TYPE_ARP);

    // 2 arphdr
    struct rte_arp_hdr *hdr = (struct rte_arp_hdr *)(msg + sizeof(struct rte_ether_hdr));
    hdr->arp_hardware = htons(1);
    hdr->arp_protocol = htons(RTE_ETHER_TYPE_IPV4);
    hdr->arp_hlen = RTE_ETHER_ADDR_LEN;
    hdr->arp_plen = sizeof(uint32_t);
    hdr->arp_opcode = htons(RTE_ARP_OP_REPLY);

    rte_memcpy(hdr->arp_data.arp_sha.addr_bytes, gSrcMac, RTE_ETHER_ADDR_LEN);
    hdr->arp_data.arp_sip = sip;
    rte_memcpy(hdr->arp_data.arp_tha.addr_bytes, dst_mac, RTE_ETHER_ADDR_LEN);
    hdr->arp_data.arp_tip = tip;
}

static int encode_udp(uint8_t *msg, unsigned char *data, uint16_t length)
{
    // encode

    // 1 ethhdr
    /*
    | Destination MAC | Source MAC      | Type  |
    |-----------------|-----------------|-------|
    | 00 1A 2B 3C 4D 5E | 00 0A 0B 0C 0D 0E | 08 00 |
    */
    struct rte_ether_hdr * eth = (struct rte_ether_hdr * )msg;
    rte_memcpy(eth->s_addr.addr_bytes, gSrcMac, RTE_ETHER_ADDR_LEN);
    rte_memcpy(eth->d_addr.addr_bytes, gDstMac, RTE_ETHER_ADDR_LEN);
    eth->ether_type = htons(RTE_ETHER_TYPE_IPV4);

    // 2 iphdr
    struct rte_ipv4_hdr * ip = (struct rte_ipv4_hdr *)(msg + sizeof(struct rte_ether_hdr));
    ip->version_ihl = 0x45;
    ip->type_of_service = 0;
    ip->total_length = htons(length - sizeof(struct rte_ether_hdr));
    ip->packet_id = 0;
    ip->fragment_offset = 0;
    ip->time_to_live = 64;
    ip->next_proto_id = IPPROTO_UDP;
    ip->src_addr = gSrcIp;
    ip->dst_addr = gDstIp;
    
    ip->hdr_checksum = 0;
    ip->hdr_checksum = rte_ipv4_cksum(ip);

    // 3 udphdr
    struct rte_udp_hdr *udp = (struct rte_udp_hdr *)(msg + sizeof(struct rte_ether_hdr) + sizeof(struct rte_ipv4_hdr));
    udp->src_port = gSrcPort;
    udp->dst_port = gDstPort;
    
    uint16_t udplen = length - sizeof(struct rte_ether_hdr) - sizeof(struct rte_ipv4_hdr);
    udp->dgram_len = htons(udplen);
    
    rte_memcpy((uint8_t *)(udp+1), data, udplen);

    udp->dgram_cksum = 0;
    udp->dgram_cksum = rte_ipv4_udptcp_cksum(ip, udp);
}

static struct rte_mbuf * ng_send_udp(struct rte_mempool *mbuf_pool, uint8_t *data, uint16_t length)
{
    // 从内存池中获取的长度
    const unsigned total_len = length + 14 + 20 + 8;

    struct rte_mbuf *mbuf = rte_pktmbuf_alloc(mbuf_pool);
    if (!mbuf)
    {
        rte_exit(EXIT_FAILURE, "Alloc\n");
    }
    mbuf->pkt_len = total_len;
    mbuf->data_len = total_len;

    uint8_t *pktdata = rte_pktmbuf_mtod(mbuf, uint8_t*);

    // 格式化upd数据报文
    encode_udp(pktdata, data, total_len);

    return mbuf;
}

// 发送arp协议
static struct rte_mbuf * ng_send_arp(struct rte_mempool *mbuf_pool, uint8_t *data_mac, uint32_t sip, uint32_t tip)
{
    // 从内存池中获取的长度
    const unsigned total_len = sizeof(struct rte_ether_hdr) + sizeof(struct rte_arp_hdr);

    struct rte_mbuf *mbuf = rte_pktmbuf_alloc(mbuf_pool);
    if (!mbuf)
    {
        rte_exit(EXIT_FAILURE, "Alloc\n");
    }
    mbuf->pkt_len = total_len;
    mbuf->data_len = total_len;

    uint8_t *pktdata = rte_pktmbuf_mtod(mbuf, uint8_t*);

    // 格式化upd数据报文
    encode_arp(pktdata, data_mac, sip, tip);

    return mbuf;
}

// 主循环：接收并处理报文
static void packet_loop(uint16_t port_id, struct rte_mempool *mbuf_pool) {
    struct rte_mbuf *rx_pkts[BURST_SIZE];
    printf("Starting packet capture on port %u...\n", port_id);

    // int rte_eth_macaddr_get(uint16_t port_id, struct rte_ether_addr *mac_addr)
    rte_eth_macaddr_get(port_id, (struct rte_ether_addr *)gSrcMac);

    while (1) {
        // 接收报文
        uint16_t nb_rx = rte_eth_rx_burst(port_id, 0, rx_pkts, BURST_SIZE);
        if (nb_rx == 0) {
            continue;
        }

        // 处理每个报文
        uint16_t i;  // 变量声明移到循环外
        for (i = 0; i < nb_rx; i++) {
            
            // 数据链路层 
            struct rte_ether_hdr *eth_hdr = rte_pktmbuf_mtod(rx_pkts[i], struct rte_ether_hdr *);
            // 传输层
            struct rte_ipv4_hdr *ip_hdr = (struct rte_ipv4_hdr *)(eth_hdr + 1);

        #if ENABLE_ARP
            if (eth_hdr->ether_type == rte_cpu_to_be_16(RTE_ETHER_TYPE_ARP))
            {
                // ARP 请求，在数据链路层上偏移可以获取整个ARP的包
                struct rte_arp_hdr *art_hdr = rte_pktmbuf_mtod_offset(rx_pkts[i], struct rte_arp_hdr *, sizeof(struct rte_ether_hdr));

                // 判断是否是访问本机的
                if (art_hdr->arp_data.arp_tip == gLocalIp)
                {
                    printf("Arp Src IP: %" PRIu8 ".%" PRIu8 ".%" PRIu8 ".%" PRIu8 "\n",
                        art_hdr->arp_data.arp_sip & 0xFF, (art_hdr->arp_data.arp_sip >> 8) & 0xFF,
                        (art_hdr->arp_data.arp_sip >> 16) & 0xFF, (art_hdr->arp_data.arp_sip >> 24) & 0xFF);
                    printf("Arp Dst IP: %" PRIu8 ".%" PRIu8 ".%" PRIu8 ".%" PRIu8 "\n",
                        art_hdr->arp_data.arp_tip & 0xFF, (art_hdr->arp_data.arp_tip >> 8) & 0xFF,
                        (art_hdr->arp_data.arp_tip >> 16) & 0xFF, (art_hdr->arp_data.arp_tip >> 24) & 0xFF);

                    // 根据请求包构造出来一个应答包，需要把源和目的的数据做一次互换
                    struct rte_mbuf * arpbuf = ng_send_arp(mbuf_pool, art_hdr->arp_data.arp_sha.addr_bytes, art_hdr->arp_data.arp_tip, art_hdr->arp_data.arp_sip);

                    // 做对应的应答
                    rte_eth_tx_burst(port_id, 0, &arpbuf, 1);
                    rte_pktmbuf_free(arpbuf);

                    rte_pktmbuf_free(rx_pkts[i]);  // 释放内存
                }
                continue;
            }
        #endif

            // 检查是否为 IPv4 报文
            if (eth_hdr->ether_type != rte_cpu_to_be_16(RTE_ETHER_TYPE_IPV4)) {
                continue;
            }

            // 检查是否为 UDP 报文
            if (ip_hdr->next_proto_id != IPPROTO_UDP)
            {
                continue;
            }
            

            struct rte_udp_hdr *udp_hdr = (struct rte_udp_hdr *)(ip_hdr + 1);

            // 提取 UDP 负载
            uint16_t udp_len = rte_be_to_cpu_16(udp_hdr->dgram_len) - sizeof(struct rte_udp_hdr);
            // uint8_t *payload = (uint8_t *)(udp_hdr + 1);

        #if ENABLE_SEND
                // 从当前报文内获取源和目的信息临时存储
                rte_memcpy(gDstMac, eth_hdr->s_addr.addr_bytes, RTE_ETHER_ADDR_LEN);
                rte_memcpy(&gSrcIp, &ip_hdr->dst_addr, sizeof(uint32_t));
                rte_memcpy(&gDstIp, &ip_hdr->src_addr, sizeof(uint32_t));
                rte_memcpy(&gSrcPort, &udp_hdr->dst_port, sizeof(uint16_t));
                rte_memcpy(&gDstPort, &udp_hdr->src_port, sizeof(uint16_t));
                
                // 通过总长度计算udp报文数据的长度
                uint16_t total_len = rx_pkts[i]->pkt_len;
                uint16_t l2_len = sizeof(struct rte_ether_hdr);
                uint16_t l3_len = sizeof(struct rte_ipv4_hdr);
                uint16_t l4_len = sizeof(struct rte_udp_hdr);
                uint16_t payload_len = total_len - (l2_len + l3_len + l4_len);

                // 指针+1可以实现找到当前对象的结尾位置
                struct rte_mbuf * tx_pkts = ng_send_udp(mbuf_pool, (uint8_t *)(udp_hdr+1), payload_len);

                // static inline uint16_t rte_eth_tx_burst(uint16_t port_id, uint16_t queue_id, struct rte_mbuf **tx_pkts, uint16_t nb_pkts)
                rte_eth_tx_burst(port_id, 0, &tx_pkts, 1);
                rte_pktmbuf_free(tx_pkts);
        #endif

            // 打印报文信息
            printf("\n=== UDP Packet ===\n");
            printf("Src MAC: %02" PRIx8 ":%02" PRIx8 ":%02" PRIx8 ":%02" PRIx8 ":%02" PRIx8 ":%02" PRIx8 "\n",
                eth_hdr->s_addr.addr_bytes[0], eth_hdr->s_addr.addr_bytes[1],
                eth_hdr->s_addr.addr_bytes[2], eth_hdr->s_addr.addr_bytes[3],
                eth_hdr->s_addr.addr_bytes[4], eth_hdr->s_addr.addr_bytes[5]);
            printf("Dst MAC: %02" PRIx8 ":%02" PRIx8 ":%02" PRIx8 ":%02" PRIx8 ":%02" PRIx8 ":%02" PRIx8 "\n",
                eth_hdr->d_addr.addr_bytes[0], eth_hdr->d_addr.addr_bytes[1],
                eth_hdr->d_addr.addr_bytes[2], eth_hdr->d_addr.addr_bytes[3],
                eth_hdr->d_addr.addr_bytes[4], eth_hdr->d_addr.addr_bytes[5]);
            printf("Src IP: %" PRIu8 ".%" PRIu8 ".%" PRIu8 ".%" PRIu8 "\n",
                ip_hdr->src_addr & 0xFF, (ip_hdr->src_addr >> 8) & 0xFF,
                (ip_hdr->src_addr >> 16) & 0xFF, (ip_hdr->src_addr >> 24) & 0xFF);
            printf("Dst IP: %" PRIu8 ".%" PRIu8 ".%" PRIu8 ".%" PRIu8 "\n",
                ip_hdr->dst_addr & 0xFF, (ip_hdr->dst_addr >> 8) & 0xFF,
                (ip_hdr->dst_addr >> 16) & 0xFF, (ip_hdr->dst_addr >> 24) & 0xFF);
            printf("Src Port: %" PRIu16 "\n", rte_be_to_cpu_16(udp_hdr->src_port));
            printf("Dst Port: %" PRIu16 "\n", rte_be_to_cpu_16(udp_hdr->dst_port));
            printf("Payload Length: %" PRIu16 " bytes\n", udp_len);

            // // 打印 UDP 负载（16进制 + ASCII）
            // printf("Payload (Hex+ASCII):\n");
            // uint16_t i;  // 变量声明移到循环外
            // for (i = 0; i < udp_len; i++) {
            //     printf("%02x ", payload[i]);
            //     if ((i + 1) % 16 == 0 || i == udp_len - 1) {
            //         uint16_t j;  // 变量声明移到循环外
            //         for (j = i - (i % 16); j <= i; j++) {
            //             printf("%c", (payload[j] >= 32 && payload[j] <= 126) ? payload[j] : '.');
            //         }
            //         printf("\n");
            //     }
            // }
            
            rte_pktmbuf_free(rx_pkts[i]);  // 释放内存
        }

    }
}

int main(int argc, char **argv) {
    // 初始化 DPDK 环境
    int ret = rte_eal_init(argc, argv);
    if (ret < 0) {
        rte_exit(EXIT_FAILURE, "Failed to initialize DPDK EAL\n");
    }

    // 创建内存池
    struct rte_mempool *mbuf_pool = rte_pktmbuf_pool_create(
        "MBUF_POOL", NUM_MBUFS, MBUF_CACHE_SIZE, 0, RTE_MBUF_DEFAULT_BUF_SIZE, rte_socket_id());
    if (mbuf_pool == NULL) {
        rte_exit(EXIT_FAILURE, "Failed to create mbuf pool\n");
    }

    // 获取网卡数量
    uint16_t nb_ports = rte_eth_dev_count_avail();
    if (nb_ports == 0) {
        rte_exit(EXIT_FAILURE, "No available Ethernet ports\n");
    }

    // 初始化第一个网卡
    uint16_t port_id = 0;
    init_port(port_id, mbuf_pool);

    // 进入主循环
    packet_loop(port_id, mbuf_pool);

    return 0;
}
```
